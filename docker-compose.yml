version: "3.4"

services:
  # We use two images in development. One frontend that runs `vue-cli-service
  # serve`, named `frontend` and one that runs django named `bev`. The frontend
  # image proxies requests to django.

  # In production only the django image is run. It will serve the production
  # ready frontend code, but the files are only updated on docker build.
  frontend:
    build:
      context: .
      dockerfile: docker/Dockerfile
      target: frontend
    environment:
      # `vue-cli-service serve` will proxy request to `/api` to this endpoint.
      # Defined in `frontend/vue.config.js`.
      - API_SERVER=http://bev:5000
    # To reload on file changes, we mount the current folder into `/code`.
    # However we do not want node_modules on the host machine, so we create an
    # additional volume for it.
    volumes:
      - .:/code/
      - /code/frontend/node_modules
    depends_on:
      - bev
    ports:
      - 8080:8080

  bev:
    build:
      context: .
      dockerfile: docker/Dockerfile
      target: dist
    # The `volumes` and `command` mounts the current directory in the docker
    # container and overwrites the CMD from Dockerfile. With this gunicorn
    # reloads on file changes. This is very useful when developing.
    #
    # You'll properly want to make `backend/core/migrations` writable by the
    # user running inside the docker container. Run `chmod o+w migrations` on it
    # to make it writeable by everyone. See README.md#user-permissions for more
    # info.
    command: |
      sh -c "python manage.py initialize_database &&
             gunicorn -b 0.0.0.0:5000 --reload --access-logfile - bevillingsplatform.wsgi"
    volumes:
      - .:/code/
      - ./dev-environment/dev-settings.ini:/user-settings.ini
    depends_on:
      - db
      - postfix
    environment:
      - PUBLIC_HOST_NAME=${PUBLIC_HOST_NAME}
    # If you want to reach the django image directly (as opposed through the
    # `vue-cli-service serve` proxy), expose it with:
    #ports:
    # - 5000:5000


  db:
    image: postgres:10
    env_file:
      - dev-environment/db.env
    volumes:
      - ./docker/postgres-initdb.d/20-create-db-and-user.sh:/docker-entrypoint-initdb.d/20-create-db-and-user.sh
      # The following file adds the CREATEDB clause to the db user to enable it
      # to run django tests. This should not be used in production.
      - ./dev-environment/postgres-initdb.d/30-add-createdb-permission.sh:/docker-entrypoint-initdb.d/30-add-createdb-permission.sh
      #- postgres-initdb.d:/docker-entrypoint-initdb.d

  postfix:
    image: catatnight/postfix
    hostname: postfix
    domainname: bevillingsplatform-test.magenta.dk
    environment:
      - maildomain=magenta.dk
      - smtp_user=bev:bev

  idp:
    image: kristophjunge/test-saml-idp
    hostname: idp
    environment:
      - SIMPLESAMLPHP_SP_ENTITY_ID=http://${PUBLIC_HOST_NAME}:8080/api/saml2_auth/acs/
      - SIMPLESAMLPHP_SP_ASSERTION_CONSUMER_SERVICE=http://${PUBLIC_HOST_NAME}:8080/api/saml2_auth/acs/
      - SIMPLESAMLPHP_SP_SINGLE_LOGOUT_SERVICE=http://${PUBLIC_HOST_NAME}:8081/simplesaml/saml2/idp/SingleLogoutService.php
    ports:
      - 8081:8080
      - 8443:8443
    volumes:
      - ./backend/core/data/authsources.php:/var/www/simplesamlphp/config/authsources.php
  # The following service is to copy the scripts needed to initialize the
  # database with user and extensions to a volume. It is not needed when the
  # volume `./docker/postgres-initdb.d/:/docker-entrypoint-initdb.d` is bound in
  # db above.
  bev-cp:
    build:
      context: .
      dockerfile: docker/Dockerfile
      target: dist
    user: root
    entrypoint: []
    command: ["cp", "-r", "/code/docker/postgres-initdb.d/20-create-db-and-user.sh", "/postgres-initdb.d/"]
    volumes:
      - postgres-initdb.d:/postgres-initdb.d


volumes:
  postgres-initdb.d:
